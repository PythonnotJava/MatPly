//// Created by 20281 on 2024/7/6.//#ifndef MATPLY_MATBOX_H#define MATPLY_MATBOX_H#if defined _STDBOOL_H#else#include <stdbool.h>#endif#if defined _INC_STDIO#else#include <stdio.h>#endif#if defined _MATH_H_#else#include <math.h>#endif#if defined _INC_STDLIB#else#include <stdlib.h>#endif#include "Auxiliary.h"// 定义并导出全局变量 ROUNDextern void set_round(const char* new_round);// 矩阵是否为特殊矩阵typedef struct SpecialAttributes{    bool identityMatrix;  // 单位矩阵    bool principalDiagonalMatrix; // 主对角矩阵    bool subDiagonalMatrix; // 副对角矩阵    bool upperTriangularMatrix; // 上三角矩阵    bool lowerTriangularMatrix; // 下三角矩阵    bool singularMatrix; // 奇异矩阵} Spc;typedef struct Matrix{    int row;  // 行    int column;  // 列    Spc * spc;  // 特殊性质    double ** data;  // 值} Matrix;// 创建所有矩阵都拥有的步骤Matrix * __new__(const int row, const int column);// 创建带有数据的矩阵，顺便可以指定特殊属性，如果知道Matrix * __init__(const int row, const int column, double data[][column], Spc * spc);// 可视化矩阵void VisibleMatrix(const Matrix * matrix);// 释放二维数组void __delete__data__(double ** data, const int row);// 销毁矩阵void __delete__(Matrix * matrix);// 创建被某个指定值填充的矩阵Matrix * filled(const int row, const int column, const double number);// 0/1矩阵Matrix * zeros(const int row, const int column);Matrix * ones(const int row, const int column);// 打印矩阵有哪些特殊属性void VisibleMatrixSpc(const Matrix * matrix);// 获取某行的数组double * row_(const int row, const Matrix * matrix);// 获取某列的数组double * column_(const int column, const Matrix * matrix);// 获取指定位置double at(const int row, const int column, const Matrix * matrix);// 判断是不是方阵bool isSquare(const Matrix * matrix);// 获取对应的转置矩阵Matrix * transpose(const Matrix * matrix);// 初等行变换：行交换、行扩大（允许0倍）、一行加倍数另一行（把size * row2 加到row1)void exchangeR(const int row1, const int row2, const Matrix * matrix);void multiplyR(const int row, const double size, const Matrix * matrix);void addR(const int row1, const int row2, const double size, const Matrix * matrix);// 初等列变换：类似上面void exchangeC(const int column1, const int column2, const Matrix * matrix);void multiplyC(const int column, const double size, const Matrix * matrix);void addC(const int column1, const int column2, const double size, const Matrix * matrix);// 矩阵加法// 1.整体加某个数——创建新对象Matrix * addNumber(const double number, const Matrix * matrix);// 2.矩阵相加——创建新对象Matrix * addMatrix(const Matrix * matrix1, const Matrix * matrix2);// 3.整体加某个数——自操作void addNumberNoReturned(const double number, const Matrix * matrix);// 4.矩阵相加——自操作，修改matrix1，下同void addMatrixNoReturned(const Matrix * matrix1, const Matrix * matrix2);// 对应的减法Matrix * minusMatrix(const Matrix * matrix1, const Matrix * matrix2);void minusMatrixNoReturned(const Matrix * matrix1, const Matrix * matrix2);// 矩阵乘法// 1.左行右列做内积Matrix * matmul(const Matrix * matrix1, const Matrix * matrix2);// 2.哈达马积void multiplyMatrixNoReturned(const Matrix * matrix1, const Matrix * matrix2);Matrix * multiplyMatrix(const Matrix * matrix1, const Matrix * matrix2);// 3.数值倍乘void multiplyNumberNoReturned(const double number, const Matrix * matrix);Matrix * multiplyNumber(const double number, const Matrix * matrix);// 4.克罗内克积Matrix * kronecker(const Matrix * matrix1, const Matrix * matrix2);// 矩阵除法Matrix * divide(const double number, const Matrix * matrix);void divideNoReturned(const double number, const Matrix * matrix);// 生成连续个数后重新布局，从start ~ row*column，间隔为1Matrix * arrange(const double start, const int row, const int column);// 生成连续个数后重新布局，从start ~ end?，期间被分成row * column份，keep为true决定以end结尾，反之Matrix * linspace(const double start, const double end, const int row, const int column, const bool keep);// 矩阵求迹，像众多科学计算库一样，只考虑最小维度double trace(const Matrix * matrix);// 行列式值，前提是方阵double det(const Matrix * matrix);// 获取一个n阶单位矩阵Matrix * E(const int n);// 余子式组成的矩阵Matrix * cofactor(const int row, const int column, const Matrix * matrix);// 逆矩阵（非奇异矩阵），前提是行列式值不能为0，默认可逆，在目标语言中判断，同上面很多的范围判断，都在目标语言，因为C没有较好的报错机制Matrix * inverse(const Matrix * matrix, const double det);// 伴随矩阵。m * adj(m) = det(m) * E;任意方阵都有伴随矩阵Matrix * adjugate(const Matrix * matrix);// 深拷贝Matrix * deepcopy(const Matrix * matrix);// 比较模式，对应位置上的数据分别对比// mode从1~4分别表示：大于、小于、不大于、不小于，其他数表示等于情况bool ** compare(const Matrix *matrix1, const Matrix *matrix2, const int mode);// 求和。参数dim可以取0、1和其他数，分别表示沿着row、沿着column、整体这三种模式的求和，下同double * sum(const Matrix * matrix, const int dim);// 求平均值double * mean(const Matrix * matrix, const int dim);// 最小值double * min(const Matrix * matrix, const int dim);// 最大值double * max(const Matrix * matrix, const int dim);// 判断数据是不是一样bool data_isSame(const double ** data1, const double ** data2, const int row, const int column);// 判断属性是不是一样bool spc_isSame(const Spc * spc1, const Spc * spc2);// 内部截取Matrix * cut(const Matrix * matrix, const int row, const int column, const int width, const int height);// 从内部一点开始截取，可以越界，超过部分使用number补全Matrix * cutfree(const Matrix * matrix, const int row, const int column, const int width, const int height, const double number);// 合并新的Matrix * concatR(const Matrix * matrix1, const Matrix * matrix2);Matrix * concatC(const Matrix * matrix1, const Matrix * matrix2);// 重塑大小——多余的丢掉，缺少的用number补全Matrix * resizeR(const Matrix * matrix, const int row, const int column, const double number);Matrix * resizeC(const Matrix * matrix, const int row, const int column, const double number);void resizeRNoReturned(Matrix * matrix, const int row, const int column, const double number);void resizeCNoReturned(Matrix * matrix, const int row, const int column, const double number);// 重构尺寸，前提是a * b = c * r;Matrix * reshape(const Matrix * matrix, const int row, const int column);void reshapeNoReturned(Matrix * matrix, const int row, const int column);// 设置随机种子void setSeed(const int seed);// 获取一个无定义数double getnan();// 获取一个无穷数double getinf();// @extend? 均匀分，如果未来实现了写了向量类，可能还会修改，一般生成是一个向量Matrix * uniform(const double start, const double end, const int row, const int column, const int seed, bool use);// @extend? 正态分布，基于Box-Muller变换Matrix * normal(const double mu, const double sigma, const int row,    const int column, const int start, const int end, const int seed, bool use );// @extend? 泊松分布Matrix * poisson(const double lambda, const int row, const int column, const int seed, bool use );// @extend? Sigmoid函数Matrix * sigmoid(const Matrix * matrix);// @extend Softmax函数Matrix * softmax(const Matrix * matrix);// 数学拓展/*double acos(double x); mode == 0double asin(double x);double atan(double x);double cos(double x);double sin(double x);double tan(double x);double cosh(double x);double sinh(double x);double tanh(double x);double exp(double x);double log(double x);double log10(double x);double sqrt(double x);double ceil(double x);double floor(double x);double fabs(double x); mode == 15double frexp(double x, int *exp);  // 不提供double ldexp(double x, int exp);  // 不提供double modf(double x, double *iptr);  // 不提供double pow(double x, double y);double atan2(double y, double x); */// 各种数学运算调用——传入1个参数Matrix * mathBasement1(const Matrix * matrix, const int mode);// 各种数学运算调用——传入2个参数，第1个是矩阵的数据，第2个是传入数据Matrix * mathBasement2(const Matrix * matrix, const int mode, const double number);// 各种数学运算调用——传入2个参数，第2个是矩阵的数据，第1个是传入数据Matrix * mathBasement2reverse(const Matrix * matrix, const int mode, const double number);#endif //MATPLY_MATBOX_H