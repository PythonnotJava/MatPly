//// Created by 20281 on 2024/7/6.//#ifndef MATPLY_MATBOX_H#define MATPLY_MATBOX_H#include <stdio.h>#include <stdlib.h>#include <stdbool.h>#include <math.h>#include "Auxiliary.h"#define ROUND "%.5lf\t"  // 输出精度// 矩阵是否为特殊矩阵typedef struct SpecialAttributes{    bool identityMatrix;  // 单位矩阵    bool principalDiagonalMatrix; // 主对角矩阵    bool subDiagonalMatrix; // 副对角矩阵    bool upperTriangularMatrix; // 上三角矩阵    bool lowerTriangularMatrix; // 下三角矩阵    bool singularMatrix; // 奇异矩阵} Spc;typedef struct Matrix{    int row;  // 行    int column;  // 列    Spc * spc;  // 特殊性质    double ** data;  // 值} Matrix;// 创建所有矩阵都拥有的步骤Matrix * __new__(const int row, const int column);// 创建带有数据的矩阵，顺便可以指定特殊属性，如果知道Matrix * __init__(const int row, const int column, double data[][column], Spc * spc);// 可视化矩阵void VisibleMatrix(const Matrix * matrix);// 销毁矩阵void __delete__(Matrix * matrix);// 创建被某个指定值填充的矩阵Matrix * filled(const int row, const int column, const double number);// 0/1矩阵Matrix * zeros(const int row, const int column);Matrix * ones(const int row, const int column);// 打印矩阵有哪些特殊属性void VisibleMatrixSpc(const Matrix * matrix);// 获取某行的数组double * row_(const int row, const Matrix * matrix);// 获取某列的数组double * column_(const int column, const Matrix * matrix);// 获取指定位置double at(const int row, const int column, const Matrix * matrix);// 判断是不是方阵bool isSquare(const Matrix * matrix);// 获取对应的转置矩阵Matrix * transpose(const Matrix * matrix);// 初等行变换：行交换、行扩大（允许0倍）、一行加倍数另一行（把size * row2 加到row1)void exchangeR(const int row1, const int row2, const Matrix * matrix);void multiplyR(const int row, const double size, const Matrix * matrix);void addR(const int row1, const int row2, const double size, const Matrix * matrix);// 初等列变换：类似上面void exchangeC(const int column1, const int column2, const Matrix * matrix);void multiplyC(const int column, const double size, const Matrix * matrix);void addC(const int column1, const int column2, const double size, const Matrix * matrix);// 矩阵加法// 1.整体加某个数——创建新对象Matrix * addNumber(const double number, const Matrix * matrix);// 2.矩阵相加——创建新对象Matrix * addMatrix(const Matrix * matrix1, const Matrix * matrix2);// 3.整体加某个数——自操作void addNumberNoReturned(const double number, const Matrix * matrix);// 4.矩阵相加——自操作，修改matrix1，下同void addMatrixNoReturned(const Matrix * matrix1, const Matrix * matrix2);// 对应的减法Matrix * minusMatrix(const Matrix * matrix1, const Matrix * matrix2);void minusMatrixNoReturned(const Matrix * matrix1, const Matrix * matrix2);// 矩阵乘法// 1.左行右列做内积Matrix * matmul(const Matrix * matrix1, const Matrix * matrix2);// 2.哈达马积void multiplyMatrixNoReturned(const Matrix * matrix1, const Matrix * matrix2);Matrix * multiplyMatrix(const Matrix * matrix1, const Matrix * matrix2);// 3.数值倍乘void multiplyNumberNoReturned(const double number, const Matrix * matrix);Matrix * multiplyNumber(const double number, const Matrix * matrix);// 4.克罗内克积Matrix * kronecker(const Matrix * matrix1, const Matrix * matrix2);// 矩阵除法Matrix * divide(const double number, const Matrix * matrix);void divideNoReturned(const double number, const Matrix * matrix);// 生成连续个数后重新布局，从start ~ row*column，间隔为1Matrix * arrange(const double start, const int row, const int column);// 生成连续个数后重新布局，从start ~ end?，期间被分成row * column份，keep为true决定以end结尾，反之Matrix * linspace(const double start, const double end, const int row, const int column, const bool keep);// 矩阵求迹，像众多科学计算库一样，只考虑最小维度double trace(const Matrix * matrix);// 行列式值，前提是方阵double det(const Matrix * matrix);// 获取一个n阶单位矩阵Matrix * E(const int n);// 余子式组成的矩阵Matrix * cofactor(const int row, const int column, const Matrix * matrix);// 逆矩阵（非奇异矩阵），前提是行列式值不能为0，默认可逆，在目标语言中判断，同上面很多的范围判断，都在目标语言，因为C没有较好的报错机制Matrix * inverse(const Matrix * matrix, const double det);// 伴随矩阵。m * adj(m) = det(m) * E;任意方阵都有伴随矩阵Matrix * adjugate(const Matrix * matrix);// 深拷贝Matrix * deepcopy(const Matrix * matrix);#endif //MATPLY_MATBOX_H