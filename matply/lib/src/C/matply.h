//// Created by 20281 on 2024/7/6.//#ifndef MATPLY_MATBOX_H#define MATPLY_MATBOX_H#if defined _STDBOOL_H#else#include <stdbool.h>#endif#if defined _INC_STDIO#else#include <stdio.h>#endif#if defined _MATH_H_#else#include <math.h>#endif#if defined _INC_STDLIB#else#include <stdlib.h>#endif#if defined _INC_STRING#else#include <string.h>#endif#if defined _TIME_H_#else#include <time.h>#endif#include "Auxiliary.h"// 设置与获取可视化精度 ROUNDMATPLY_API extern void set_visible_round( char* new_round);MATPLY_API extern char * get_visible_round();// 设置与获取浮点数误差精度MATPLY_API extern void set_round( double number);MATPLY_API extern double get_round();MATPLY_API extern const double PI;MATPLY_API extern const double e;MATPLY_API extern const double _nan;MATPLY_API extern const double inf;MATPLY_API extern const double euler;// 矩阵是否为特殊矩阵typedef struct SpecialAttributes{    bool identityMatrix;  // 单位矩阵    bool principalDiagonalMatrix; // 主对角矩阵    bool subDiagonalMatrix; // 副对角矩阵    bool upperTriangularMatrix; // 上三角矩阵    bool lowerTriangularMatrix; // 下三角矩阵    bool singularMatrix; // 奇异矩阵} Spc;typedef struct Matrix{    int row;  // 行    int column;  // 列    Spc * spc;  // 特殊性质    double ** data;  // 值} Matrix;typedef struct MultiDatas2 {    double ** data1;    double ** data2;} MultiDatas2;typedef struct MultiDatas3 {    double ** data1;    double ** data2;    double ** data3;} MultiDatas3;typedef struct MultiDatas4 {    double ** data1;    double ** data2;    double ** data3;    double ** data4;} MultiDatas4;/// 内存管理，使用一个单例内存池。防止内存泄漏。/// 内存池由双向链表实现——自 V1.0.8///////////////////////////////////////////////////////////////////////////////////////struct MatrixLinked{    struct MatrixLinked * next;    Matrix * matrix;};typedef struct MatrixLinked MatrixLinked;typedef struct MemoryPool{    int instances;  // 存储实例个数    MatrixLinked * head;    MatrixLinked * tail;} MemoryPool;static struct MemoryPool __Mp = (MemoryPool){0, NULL, NULL};// 添加到内存池// 选择性初始化，matrix可以为空，只是为了更好的提示矩阵操作的开始；另外，内存池真的为空的话，则可以把非空的matrix设置为第一个// 头节点包含第一个实例、尾节点不包含最后一个实例而作为最后一个节点MATPLY_API void initMp(Matrix * matrix);// 尾部添加MATPLY_API void addToMp(Matrix * matrix);// 释放——是否可视化地址、可视化地址是否输出为十六进制地址（false为十进制）。另外，可视化地址不设为矩阵的，而是节点的MATPLY_API void freeMp(bool visible, bool hex);MATPLY_API int getInstances();#define Signal(m) addToMp(m);///////////////////////////////////////////////////////////////////////////////////////MATPLY_API void visible_data( double**matrix,  int row,  int column);// 创建所有矩阵都拥有的步骤MATPLY_API Matrix * __new__( int row,  int column);// 创建带有数据的矩阵，顺便可以指定特殊属性，如果知道MATPLY_API Matrix * __init__( int row,  int column,  double** data,  Spc * spc);// 创建指定地址数据的矩阵，顺便可以指定特殊属性，如果知道MATPLY_API Matrix * __init__point__data__( int row,  int column, double ** data,  Spc * spc);// 可视化矩阵MATPLY_API void VisibleMatrix( Matrix * matrix);// 释放二维数组MATPLY_API void __delete__data__(double ** data,  int row);// 销毁矩阵MATPLY_API void __delete__(Matrix * matrix);// 创建被某个指定值填充的矩阵MATPLY_API double ** filled( int row,  int column,  double number);// 0/1矩阵MATPLY_API double ** zeros( int row,  int column);MATPLY_API double ** ones( int row,  int column);// 打印矩阵有哪些特殊属性MATPLY_API void VisibleMatrixSpc( Matrix * matrix);// 获取某行的数组MATPLY_API double * row_( int row,  int column,  double ** data);// 获取某列的数组MATPLY_API double * column_( int row,  int column,  double ** data);// 获取指定位置MATPLY_API double at( int row,  int column,  double ** data);// 判断是不是方阵MATPLY_API bool isSquare( Matrix * matrix);// 获取对应的转置矩阵MATPLY_API double ** transpose( int row,  int column,  double ** data);// 初等行变换：行交换、行扩大（允许0倍）、一行加倍数另一行（把size * row2 加到row1)MATPLY_API void exchangeR( int column, double ** data,  int row1,  int row2);MATPLY_API void multiplyR( int row,  int column, double **data,  double size);MATPLY_API void addR( int column, double **data,  int row1,  int row2,  double size);// 初等列变换：类似上面MATPLY_API void exchangeC( int row, double ** data,  int column1,  int column2);MATPLY_API void multiplyC( int row,  int column, double **data,  double size);MATPLY_API void addC( int row, double **data,  int column1,  int column2,  double size);// 矩阵加法// 1.整体加某个数——创建新对象MATPLY_API double ** addNumber( int row,  int column,  double **data,  double number);// 2.矩阵相加——创建新对象MATPLY_API double ** addMatrix( int row,  int column,  double **data1,  double **data2);// 3.整体加某个数——自操作MATPLY_API void addNumberNoReturned( int row,  int column, double **data,  double number);// 4.矩阵相加——自操作，修改matrix1，下同MATPLY_API void addMatrixNoReturned( int row,  int column, double **data1,  double **data2);// 对应的减法MATPLY_API double ** minusMatrix( int row,  int column,  double **data1,  double **data2);MATPLY_API void minusMatrixNoReturned( int row,  int column, double **data1,  double **data2);// 矩阵乘法// 1.左行右列做内积MATPLY_API double ** matmul( int row,  int column,  double **data1,  double **data2, int column2);// 2.哈达马积MATPLY_API void multiplyMatrixNoReturned( int row,  int column, double **data1,  double **data2);double ** multiplyMatrix( int row,  int column,  double **data1,  double **data2);// 3.数值倍乘MATPLY_API void multiplyNumberNoReturned( int row,  int column, double **data,  double number);MATPLY_API double ** multiplyNumber( int row,  int column,  double **data,  double number);// 4.克罗内克积MATPLY_API double ** kronecker( int row1,  int column1,  double **data1,  int row2,  int column2,  double **data2);// 矩阵除法MATPLY_API double ** divide( int row,  int column,  double **data,  double number);MATPLY_API void divideNoReturned( int row,  int column, double **data,  double number);// 生成连续个数后重新布局，从start ~ row*column，间隔为1MATPLY_API double ** arrange( double start,  int row,  int column);// 生成连续个数后重新布局，从start ~ end?，期间被分成row * column份，keep为true决定以end结尾，反之MATPLY_API double ** linspace( double start,  double end,  int row,  int column,  bool keep);// 矩阵求迹，像众多科学计算库一样，只考虑最小维度MATPLY_API double trace( int row,  int column,  double **data);// 行列式值，前提是方阵MATPLY_API double det( int row,  int column,  double **data);// 获取一个n阶单位矩阵MATPLY_API double ** E( int n);// 余子式组成的矩阵MATPLY_API double ** cofactor( int row,  int column,  double ** data,  int prow,  int pcolumn);// 伴随矩阵。m * adj(m) = det(m) * E;任意方阵都有伴随矩阵MATPLY_API double ** adjugate( int row,  int column,  double ** data);// 逆矩阵（非奇异矩阵），前提是行列式值不能为0，默认可逆，在目标语言中判断，同上面很多的范围判断，都在目标语言，因为C没有较好的报错机制MATPLY_API double ** inverse( int row,  int column,  double ** data, double det);// 深拷贝MATPLY_API double ** deepcopy( int row,  int column,  double **data);// 比较模式，对应位置上的数据分别对比// mode从1~4分别表示：大于、小于、不大于、不小于，其他数表示等于情况MATPLY_API bool ** compare( int row,  int column,  double **data1,  double ** data2,  int mode);// 求和。参数dim可以取0、1和其他数，分别表示沿着row、沿着column、整体这三种模式的求和，下同MATPLY_API double * sum( int row,  int column,  double **data,  int dim);// 求平均值MATPLY_API double * mean( int row,  int column,  double **data,  int dim);// 最小值MATPLY_API double * min( int row,  int column,  double **data,  int dim);// 最大值MATPLY_API double * max( int row,  int column,  double **data,  int dim);// 判断数据是不是一样MATPLY_API bool data_isSame( int row,  int column,  double ** data1,  double ** data2);// 判断属性是不是一样MATPLY_API bool spc_isSame( Spc * spc1,  Spc * spc2);// 内部截取MATPLY_API double ** cut( int row,  int column,  double ** data,  int prow,  int pcolumn,  int width,  int height);// 从内部一点开始截取，可以越界，超过部分使用number补全double ** cutfree( int row,  int column,  double ** data,  int prow,  int pcolumn,  int width,  int height,  double number);// 合并新的MATPLY_API double ** concatR( int row,  int column1,  int column2,  double ** data1,  double ** data2);MATPLY_API double ** concatC( int row1,  int row2,  int column,  double ** data1,  double ** data2);// 重塑大小——多余的丢掉，缺少的用number补全// 这个row和column是新尺寸的，别弄混了MATPLY_API double ** resizeR( int row,  int column,  double ** data,  int origin_row,  int origin_column,  double number);MATPLY_API double ** resizeC( int row,  int column,  double ** data,  int origin_row,  int origin_column,  double number);// 重构尺寸，前提是a * b = c * r;MATPLY_API double ** reshape( int row,  int column,  double ** data,  int origin_column);// 设置随机种子MATPLY_API void setSeed( int seed);// 数学拓展/*double acos(double x); mode == 0double asin(double x);double atan(double x);double cos(double x);double sin(double x);double tan(double x);double cosh(double x);double sinh(double x);double tanh(double x);double exp(double x);double log(double x);double log10(double x);double sqrt(double x);double ceil(double x);double floor(double x);double fabs(double x); mode == 15double pow(double x, double y); 0double atan2(double y, double x); 1double frexp(double x, int *exp);  // 不提供double ldexp(double x, int exp);  // 不提供double modf(double x, double *iptr);  // 不提供 */// 各种数学运算调用——传入1个参数，这么设计泛型是为了节省代码量，同时在一些语言中，如Dart可以轻松使用extension关键字对List拓展MATPLY_API double ** mathBasement1( int row,  int column,  double ** data,  int mode);// 各种数学运算调用——传入2个参数，第1个是矩阵的数据，第2个是传入数据MATPLY_API double ** mathBasement2( int row,  int column,  double ** data,  int mode,  double number);// 各种数学运算调用——传入2个参数，第2个是矩阵的数据，第1个是传入数据MATPLY_API double ** mathBasement2reverse( int row,  int column,  double ** data,  int mode,  double number);// Sigmoid函数MATPLY_API double ** sigmoid( int row,  int column,  double ** data);// @extend Softmax函数，归一化指数函数，当数据含有nan或者正负inf任意一种时，可对二者做特殊化处理MATPLY_API double ** softmax( int row,  int column,  double ** data,  int dim,  double mask_nan,  double mask_inf,  double mask_neginf);// 随机打乱MATPLY_API void shuffle(  int row,  int column, double ** data);// 排序，reverse为true表示从大到小MATPLY_API void sortNoReturned( int row,  int column, double ** data,  bool reverse,  int dim,  double mask_nan);MATPLY_API double ** sort( int row,  int column, double ** data,  bool reverse,  int dim,  double mask_nan);// 均匀分，如果未来实现了写了向量类，可能还会修改，一般生成是一个向量MATPLY_API double ** uniform( int row,  int column,  double start,  double end,  int seed,  bool use);// 正态分布，基于Box-Muller变换MATPLY_API double ** normal( int row,  int column,  double mu,  double sigma,  int seed,  bool use );// 泊松分布MATPLY_API double ** poisson( int row,  int column,  double lambda,  int seed,  bool use);// 得到化最简阶梯型矩阵MATPLY_API double ** rref( int row,  int column,  double ** data);// 对一个矩阵进行特殊值处理MATPLY_API void set_mask_nan( int row,  int column, double ** data,  double number);MATPLY_API void set_mask_inf( int row,  int column, double ** data,  double number,  bool isNegativeInf);// 矩阵的秩MATPLY_API int rank( int row,  int column,  double ** data);MATPLY_API double ** testArray( int row,  int column);// @ignore 数学期望不需要实现，因为数学期望是随机变量 * 概率，可以使用哈达玛积表示// 方差，如果声明sample则表示样本方差；标准差开根号就行MATPLY_API double * variance(int row, int column, double ** data, bool sample, int dim, bool std);// 中位数MATPLY_API double * median(int row, int column, double ** data, int dim);// 矩阵范数// n == -2表示负无穷范数，即矩阵每行绝对值元素求和取最小MATPLY_API double norm_negainf(int row, int column, double ** data);// n == -1表示正无穷范数，即矩阵每行绝对值元素求和取最大MATPLY_API double norm_inf(int row, int column, double ** data);// n == 0获取0范数，也是获取数据的稀疏度。数据会与定义的浮点误差比较，而不是直接与0比较，k范数时（k == 0 or k >= 2），程序灵活些，加个dim参数MATPLY_API double * norm_zero(int row, int column, double ** data, int dim);// n == 1矩阵的1范数，矩阵每列绝对值元素求和取最大MATPLY_API double norm_one(int row, int column, double ** data);MATPLY_API double * norm(int row, int column, double ** data, int n, int dim);// 最值索引MATPLY_API int * argmax(int row, int column, double  **data, int dim);MATPLY_API int * argmin(int row, int column, double  **data, int dim);// 数组扁平化为1*size（不用reshape实现），mode == 1表示从0列开始并从上到下转换；mode为其他值表示从行开始，从上到下MATPLY_API double * flatten(int row, int column, double  **data, int mode);// 指定步长的rangeMATPLY_API double ** range(double start, double step, int row, int column);// 替换不符合条件的值MATPLY_API double ** replace(int row, int column, double ** data, double number, bool (*condition)(double ));MATPLY_API void replaceNoReturned(int row, int column, double ** data, double number, bool (*condition)(double ));// 数据归一化// 分别是线性归一化、均值归一化、标准化MATPLY_API double ** normalization1(int row, int column, double  **data, int dim);MATPLY_API double ** normalization2(int row, int column, double  **data, int dim);MATPLY_API double ** normalization3(int row, int column, double  **data, int dim);// 矩阵切割，to的位置也计入MATPLY_API double ** sliceR(int column, double ** data, int from, int to);MATPLY_API double ** sliceC(int row, double ** data, int from, int to);// 框住范围MATPLY_API double ** clip(int row, int column, double  **data, double lb, double ub);MATPLY_API void clipNoReturned(int row, int column, double  **data, double lb, double ub);// 每个值都满足条件MATPLY_API bool all(int row, int column, double  ** data, bool (*condition)(double ));// 任意值满足条件MATPLY_API bool any(int row, int column, double **data, bool (*condition)(double ));// 对满足条件的数据计数MATPLY_API int * counter(int row, int column, double  ** data, int dim, bool (*condition)(double ));// 自定义两个相邻值的行为，init值是基准值，例如求和可以设置基准从0开始，乘积可以设置基准为1MATPLY_API double * reduce(int row, int column, double ** data, int dim, double (*condition)(double , double ), double init);// 获取最小维度下对角线全是1，其他全是0的矩阵MATPLY_API double ** E_like(int row, int column);// qr分解MATPLY_API MultiDatas2 qr(int row, int column, double ** data);// 反向框住，对于不符合上下限的值，可以根据传入条件设置值，其实就是replace的另一版本MATPLY_API double ** clip_reverse(int row, int column, double  **data, double lb, double ub, double (*condition)(double));MATPLY_API void clip_reverseNoReturned(int row, int column, double  **data, double lb, double ub, double (*condition)(double));// 在不创多次创建二维数组的前提下，生成一个符合运算的数组MATPLY_API double ** customize(int row, int column, double ** data, double (*condition)(double ));// 反向除法，而不是借助-1次幂MATPLY_API double ** divrev(int row, int column, double **data, double number);// 查询所有符合条件值的索引，每行都查询，其中prediction是预测平均每行有多少符合条件的值MATPLY_API int ** findIndexs(int row, int column, double **data, bool (*condition)(double ), int prediction);// 矩阵的旋转，以(0,0)为旋转点// 顺时针旋转270度的矩阵与逆时针旋转90度// 逆时针旋转270度的矩阵等同于顺时针旋转90度// 180顺逆一样// 0、360都是矩阵的拷贝，这里不实现MATPLY_API double ** rotate(int row, int column, double ** data, int mode);// 矩阵的镜像，0表示横向镜像、其他值表示总线镜像MATPLY_API double ** mirror(int row, int column, double ** data, int mode );// 去中心化MATPLY_API double ** decentralizate(int row, int column, double **data, int dim);// 协方差MATPLY_API double * covariance(int row, int column, double ** data1, double ** data2, bool sample, int dim);// 一个矩阵的协方差矩阵计算。视为：每一列是一个样本，每一行就是一个随机变量（特征）MATPLY_API double ** cov1(int row, int column, double ** data, bool sample);// 两个矩阵的协方差矩阵计算，以行为特征。MATPLY_API double ** cov2(int row, int column, double ** data1, double ** data2, bool sample);// 皮尔逊相关系数MATPLY_API double * pearsonCoef(int row, int column, double ** data1, double ** data2, bool sample, int dim);// 均方误差, rmse为true表示均方根误差MATPLY_API double * MSE(int row, int column, double ** data1, double ** data2, int dim, bool rmse);// 平均绝对误差MATPLY_API double * MAE(int row, int column, double ** data1, double ** data2, int dim);// 平均绝对百分比误差// 当真实值有数据等于0时，存在分母0除问题，该公式不可用！MATPLY_API double * MAPE(int row, int column, double ** pre, double ** rea, int dim);// 决定系数MATPLY_API double * R2(int row, int column, double ** pre, double ** rea, int dim);// 对称平均绝对百分比误差// 当真实值有数据等于0，而预测值也等于0时，存在分母0除问题，该公式不可用！MATPLY_API double * SMAPE(int row, int column, double ** data1, double ** data2, int dim);// 获取关于对角线对称的随机数矩阵，sub为true表示副对角线对称（其实row == column)MATPLY_API double ** diagonal(int row, int column, double start, double end, bool sub, int seed, bool use);// 使得矩阵最小维度下主对角线的值全部替换为某个数值MATPLY_API void fill_diagonal(int row, int column, double ** data, double number);// 在行方向上，根据概率一维数组挑选值。对应系列概率和不一定为1.0，可以是任意数，也就是说，此概率另含有占有权重的意思MATPLY_API double ** choice1(int row, int column, double ** data, double ** p, int times, bool back, int method);MATPLY_API double ** choice2(int row, int column, double ** data, double * p, int times, bool back, int method);// 等概率版本MATPLY_API double ** choice3(int row, int column, double ** data, int times, bool back);// 多拼接，data1是操作发出对象且至少data2不为空MATPLY_API double ** concatsR(int row,int column1,int column2,int column3,int column4,double ** data1,double ** data2,double ** data3,double ** data4);MATPLY_API double ** concatsC(int row1,int row2,int row3,int row4,int column,double ** data1,double ** data2,double ** data3,double ** data4);// 多次任意切分，比如(row, column)形状的数组使用{1, 3, 5}切割表示从0~1、1~3、3~5、5 ~ column切成四份(左闭右开），len是数组长度，mode=true表示横向切MATPLY_API double *** split(int row, int column, double ** data, int len, int * slices, bool mode);// 覆盖——两个矩阵重叠的地方会覆盖，data1是被覆盖对象MATPLY_API double ** cover(int row, int column, double ** data1, int row1, int column1, double ** data2, int rowx, int rowy);// 矩阵拉伸，方式为重复，hor为true表示横向拉伸，len是拉伸长度MATPLY_API double ** stretch_repeat(int row, int column, double ** data, int len, bool hor);// 矩阵拉伸，方式为替换，hor为true表示横向拉伸，len是拉伸长度，number是替换数据MATPLY_API double ** stretch_replace(int row, int column, double ** data, int len, bool hor, double number);// 矩阵拉伸，方式为头部延展，hor为true表示横向拉伸，len是拉伸长度MATPLY_API double ** stretch_head(int row, int column, double ** data, int len, bool hor);// 矩阵拉伸，方式为尾部延展，hor为true表示横向拉伸，len是拉伸长度MATPLY_API double ** stretch_end(int row, int column, double ** data, int len, bool hor);// 矩阵拉伸，方式为镜像延展，hor为true表示横向拉伸，len是拉伸长度MATPLY_API double ** stretch_mirror(int row, int column, double ** data, int len, bool hor);// 矩阵拉伸，方式为镜像的镜像，即对前一个轮回镜像再镜像，hor为true表示横向拉伸，len是拉伸长度MATPLY_API double ** stretch_mirrors(int row, int column, double ** data, int len, bool hor);// 矩阵拉伸，method表示选用的策略（policies）——重复(0)、替换(1)、头部延展(2)、尾部延展(3)、镜像(4)、镜像的镜像(其他)MATPLY_API double ** stretch(int row, int column, double ** data, int len, bool hor, double number, int method);// 在保证传入的是某定义域上的连续函数时，进行中心差分MATPLY_API double ** diffC(int row, int column, double ** data, double (*func)(double));// 获取值的上下界MATPLY_API double ** get_range(int row, int column, double ** data, int dim);#endif //MATPLY_MATBOX_H